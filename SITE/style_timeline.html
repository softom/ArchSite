<!-- TL3: Полная страница (редакция с SWITCH_UNDER_PX = 12 + исправленная анимация “вытеснения”)
Вставь целиком в ОДИН HTML-блок Tilda.

Что внутри:
- Sticky-шапка: 2 сплошные цветовые строки (ЭПОХА/СТИЛЬ), без рамок.
- В строке ЭПОХА вертикальная полоса ТОЛЬКО эпохи (стиль её не “режет”).
- В строке СТИЛЬ вертикальная полоса эпохи + полоса стиля (вплотную).
- В тексте: полосы эпохи/стиля + вертикальные даты (точные, 2 строки, без тире).
- Горизонтальные даты убраны.
- Первый заголовок эпохи и стиля в тексте скрывается (чтобы не дублировать стартовую шапку).
- Переключение в шапке: по scroll, позднее на 12px (чтобы не было двух одинаковых заголовков на экране).
- Анимация: старый текст уезжает вверх, новый въезжает снизу (с принудительным reset, чтобы не “переворачивалось” на первом переключении).
- fetch: timeout + retry.

Цвета:
- ЭПОХА: phenomena.color
- СТИЛЬ: styles.color (fallback: hashColor(slug))
-->

<div id="tl3" class="tl3">
  <div class="tl3__mainTitle">Шкала времени стилей</div>
  <div class="tl3__sticky" id="tl3Sticky">
    <div class="tl3__stickyRow tl3__stickyRow--epoch">
      <div class="tl3__stickyInner">
        <div class="tl3__stickyLabel">ЭПОХА</div>

        <div class="tl3__slot" id="tl3EpochSlot" aria-live="polite">
          <div class="tl3__slotLine tl3__slotLine--current" id="tl3EpochCurrent">Загрузка…</div>
          <div class="tl3__slotLine tl3__slotLine--next" id="tl3EpochNext"></div>
        </div>
      </div>
    </div>

    <div class="tl3__stickyRow tl3__stickyRow--style">
      <div class="tl3__stickyInner">
        <div class="tl3__stickyLabel">СТИЛЬ</div>

        <div class="tl3__slot" id="tl3StyleSlot" aria-live="polite">
          <div class="tl3__slotLine tl3__slotLine--current" id="tl3StyleCurrent"></div>
          <div class="tl3__slotLine tl3__slotLine--next" id="tl3StyleNext"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="tl3__stream" id="tl3Stream"></div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const TIMELINE_URL =
    "https://huvpoyjfdernofmatsuq.supabase.co/functions/v1/timeline?projectsPerStyle=8";

  const HIDE_FIRST_HEADINGS_IN_TEXT = true;
  const SWITCH_UNDER_PX = 12; // <-- твоя настройка: переключать когда заголовок уже на 12px под шапкой

  const elStream = document.getElementById("tl3Stream");
  const elSticky = document.getElementById("tl3Sticky");

  const elEpochSlot = document.getElementById("tl3EpochSlot");
  const elEpochCurrent = document.getElementById("tl3EpochCurrent");
  const elEpochNext = document.getElementById("tl3EpochNext");

  const elStyleSlot = document.getElementById("tl3StyleSlot");
  const elStyleCurrent = document.getElementById("tl3StyleCurrent");
  const elStyleNext = document.getElementById("tl3StyleNext");

  const missing = [];
  if (!elStream) missing.push("tl3Stream");
  if (!elSticky) missing.push("tl3Sticky");
  if (!elEpochSlot || !elEpochCurrent || !elEpochNext) missing.push("epoch slot elements");
  if (!elStyleSlot || !elStyleCurrent || !elStyleNext) missing.push("style slot elements");

  if (missing.length) {
    console.error("Ошибка разметки: отсутствуют элементы:", missing.join(", "));
    if (elEpochCurrent) elEpochCurrent.textContent = "Ошибка";
    if (elStyleCurrent) elStyleCurrent.textContent = "Ошибка разметки";
    return;
  }

  const escapeHtml = (s) => String(s ?? "")
    .replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;").replaceAll("'", "&#039;");

  const yearRange = (a, b) => {
    const left = (a === null || a === undefined) ? "?" : a;
    const right = (b === null || b === undefined) ? "н.в." : b;
    return `${left}—${right}`;
  };

  // Вертикальная метка: точные значения из БД, без тире -> две строки.
  const tickHtmlExact = (start, end) => {
    if (start === null || start === undefined || start === "") return "";
    const s = escapeHtml(String(start).trim());
    const e = (end === null || end === undefined || end === "") ? "" : escapeHtml(String(end).trim());
    return e ? `${s}<br>${e}` : s;
  };

  const hashColor = (s) => {
    let h = 0;
    const str = String(s ?? "");
    for (let i = 0; i < str.length; i++) h = (h * 31 + str.charCodeAt(i)) >>> 0;
    const hue = h % 360;
    return `hsl(${hue} 70% 45%)`;
  };

  const pickPrimaryPhenomenonId = (links) => {
    if (!Array.isArray(links) || links.length === 0) return null;
    const primary = links.find(x => x.is_primary);
    if (primary) return primary.phenomenon_id;
    return links.slice().sort((a,b)=>(a.sort_order??0)-(b.sort_order??0))[0].phenomenon_id;
  };

  async function fetchWithTimeout(url, ms) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), ms);
    try {
      return await fetch(url, { signal: ctrl.signal, cache: "no-store" });
    } finally {
      clearTimeout(t);
    }
  }

  async function fetchJsonRetry(url, tries = 3) {
    let lastErr;
    for (let i = 0; i < tries; i++) {
      try {
        const res = await fetchWithTimeout(url, 15000);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      } catch (e) {
        lastErr = e;
        await new Promise(r => setTimeout(r, 600 * (i + 1)));
      }
    }
    throw lastErr;
  }

  function setStickyColors(epochColor, styleColor) {
    elSticky.style.setProperty("--epochColor", epochColor || "#2F6FED");
    elSticky.style.setProperty("--styleColor", styleColor || "#666");
  }

  function setSlotInstant(slotEl, currentEl, nextEl, text) {
    const t = String(text || "").trim();
    slotEl.classList.add("tl3__slot--reset");
    slotEl.classList.remove("tl3__slot--anim");
    nextEl.textContent = "";
    currentEl.textContent = t;
    slotEl.dataset.current = t;
    slotEl.dataset.target = "";
    void slotEl.offsetWidth;
    slotEl.classList.remove("tl3__slot--reset");
  }

  // Устойчивая анимация: старое вверх, новое снизу
  function animateSlot(slotEl, currentEl, nextEl, newText) {
    const nxt = String(newText || "").trim();
    if (!nxt) return;

    const cur = (slotEl.dataset.current ?? String(currentEl.textContent || "").trim());
    const inFlight = String(slotEl.dataset.target || "").trim();

    if (inFlight === nxt || (inFlight === "" && cur === nxt)) return;

    // reset без анимации
    slotEl.classList.add("tl3__slot--reset");
    slotEl.classList.remove("tl3__slot--anim");
    nextEl.textContent = "";
    void slotEl.offsetWidth;

    // задаём цель и включаем анимацию
    nextEl.textContent = nxt;
    slotEl.dataset.target = nxt;

    void slotEl.offsetWidth;
    slotEl.classList.remove("tl3__slot--reset");
    slotEl.classList.add("tl3__slot--anim");

    const finish = () => {
      if (String(slotEl.dataset.target || "").trim() !== nxt) return;
      setSlotInstant(slotEl, currentEl, nextEl, nxt);
    };

    nextEl.addEventListener("transitionend", (ev) => {
      if (ev.propertyName !== "transform" && ev.propertyName !== "opacity") return;
      finish();
    }, { once: true });

    setTimeout(finish, 420);
  }

  // ===== Render cards =====
  const renderProjectCard = (p) => {
    const title = p.title_ru || p.title_original || p.slug;
    const years = yearRange(p.year_start, p.year_end);
    const place = [p.city, p.country].filter(Boolean).join(", ");
    const meta = [years, place, p.typology].filter(Boolean).join(" · ");
    const link = p.wiki_url
      ? `<a class="tl3__link" href="${escapeHtml(p.wiki_url)}" target="_blank" rel="noreferrer">Wiki</a>`
      : "";

    const imgs = Array.isArray(p.images) ? p.images.slice(0, 2) : [];
    const thumbs = imgs.length ? `
      <div class="tl3__thumbs">
        ${imgs.map(im => `
          <a class="tl3__thumb" href="${escapeHtml(im.url)}" target="_blank" rel="noreferrer">
            <img src="${escapeHtml(im.url)}" alt="${escapeHtml(im.caption_ru || '')}">
          </a>
        `).join("")}
      </div>
    ` : "";

    return `
      <div class="tl3__proj">
        <div class="tl3__projTitle">${escapeHtml(title)}</div>
        <div class="tl3__projMeta">${escapeHtml(meta)} ${link}</div>
        ${p.description_short ? `<div class="tl3__projDesc">${escapeHtml(p.description_short)}</div>` : ""}
        ${thumbs}
      </div>
    `;
  };

  // ===== Active style logic by scroll =====
  let anchors = []; // { anchorEl, epochTitle, epochColor, styleTitle, styleColor }
  let activeKey = "";

  function computeActiveByScroll() {
    if (!anchors.length) return;

    const stickyH = elSticky.getBoundingClientRect().height;
    const y = Math.max(0, stickyH - SWITCH_UNDER_PX);

    let active = anchors[0];
    for (const a of anchors) {
      const top = a.anchorEl.getBoundingClientRect().top;
      if (top <= y) active = a;
      else break;
    }

    const key = `${active.epochTitle}||${active.styleTitle}||${active.styleColor}||${active.epochColor}`;
    if (key === activeKey) return;
    activeKey = key;

    setStickyColors(active.epochColor, active.styleColor);
    animateSlot(elEpochSlot, elEpochCurrent, elEpochNext, active.epochTitle);
    animateSlot(elStyleSlot, elStyleCurrent, elStyleNext, active.styleTitle);
  }

  let rafPending = false;
  function onScroll() {
    if (rafPending) return;
    rafPending = true;
    requestAnimationFrame(() => {
      rafPending = false;
      computeActiveByScroll();
    });
  }

  const init = async () => {
    const data = await fetchJsonRetry(TIMELINE_URL, 3);

    const phenomena = Array.isArray(data.phenomena) ? data.phenomena : [];
    const styles = Array.isArray(data.styles) ? data.styles : [];

    const phById = new Map();
    phenomena.forEach(ph => phById.set(ph.id, ph));

    // group styles by primary phenomenon (contiguous)
    const groups = [];
    let current = null;
    for (const st of styles) {
      const phId = pickPrimaryPhenomenonId(st.phenomenon_links);
      if (!current || current.epochId !== phId) {
        current = { epochId: phId, styles: [] };
        groups.push(current);
      }
      current.styles.push(st);
    }

    let isFirstEpoch = true;
    let isFirstStyle = true;

    elStream.innerHTML = groups.map(g => {
      const ph = g.epochId ? phById.get(g.epochId) : null;

      const epochTitle = ph ? (ph.title_ru || ph.slug) : "—";
      const epochColor = ph?.color || "#2F6FED";
      const epochTick = tickHtmlExact(ph?.date_start_year, ph?.date_end_year);

      const epochHead = (HIDE_FIRST_HEADINGS_IN_TEXT && isFirstEpoch) ? "" : `
        <div class="tl3__epochHeadRow" style="--epochColor:${escapeHtml(epochColor)}">
          <div class="tl3__tick tl3__tick--epoch">${epochTick}</div>
          <div class="tl3__inner">
            <div class="tl3__epochHeadLabel">ЭПОХА</div>
            <div class="tl3__epochHeadValue">${escapeHtml(epochTitle)}</div>
          </div>
        </div>
      `;

      const stylesHtml = g.styles.map(st => {
        const styleTitle = st.title_ru || st.slug;

        const styleColor = (st.color && String(st.color).trim())
          ? String(st.color).trim()
          : hashColor(st.slug || styleTitle);

        const styleTick = tickHtmlExact(st.date_start_year, st.date_end_year);
        const projects = Array.isArray(st.projects) ? st.projects : [];

        const styleHead = (HIDE_FIRST_HEADINGS_IN_TEXT && isFirstStyle) ? "" : `
          <div class="tl3__styleHeadRow">
            <div class="tl3__tick tl3__tick--style">${styleTick}</div>
            <div class="tl3__inner">
              <div class="tl3__styleHeadLabel">СТИЛЬ</div>
              <div class="tl3__styleHeadValue">
                ${escapeHtml(styleTitle)}
                ${st.title_en ? `<span class="tl3__pill">${escapeHtml(st.title_en)}</span>` : ""}
              </div>
            </div>
          </div>
        `;

        isFirstStyle = false;

        return `
          <div class="tl3__styleRow"
            style="--epochColor:${escapeHtml(epochColor)}; --styleColor:${escapeHtml(styleColor)}"
            data-epoch-title="${escapeHtml(epochTitle)}"
            data-epoch-color="${escapeHtml(epochColor)}"
            data-style-title="${escapeHtml(styleTitle)}"
            data-style-color="${escapeHtml(styleColor)}"
          >
            ${styleHead}

            <div class="tl3__inner tl3__styleBody ${(!styleHead) ? "tl3__styleBody--nohead" : ""}">
              ${st.one_liner ? `<div class="tl3__one">${escapeHtml(st.one_liner)}</div>` : ""}
              ${st.description ? `<div class="tl3__desc">${escapeHtml(st.description)}</div>` : ""}

              <div class="tl3__block">
                <div class="tl3__blockTitle">Объекты</div>
                ${projects.length ? projects.map(renderProjectCard).join("") : `<div class="tl3__muted">Пока нет объектов.</div>`}
              </div>
            </div>
          </div>
        `;
      }).join("");

      isFirstEpoch = false;

      return `
        <div class="tl3__epochGroup" style="--epochColor:${escapeHtml(epochColor)}">
          ${epochHead}
          ${stylesHtml}
        </div>
      `;
    }).join("");

    // anchors in DOM order
    anchors = Array.from(elStream.querySelectorAll(".tl3__styleRow")).map(rowEl => {
      const epochTitle = rowEl.getAttribute("data-epoch-title") || "—";
      const epochColor = rowEl.getAttribute("data-epoch-color") || "#2F6FED";
      const styleTitle = rowEl.getAttribute("data-style-title") || "";
      const styleColor = rowEl.getAttribute("data-style-color") || "#666";

      const head = rowEl.querySelector(".tl3__styleHeadRow");
      const body = rowEl.querySelector(".tl3__styleBody");
      const anchorEl = head || body || rowEl;

      return { anchorEl, epochTitle, epochColor, styleTitle, styleColor };
    });

    if (anchors.length) {
      setStickyColors(anchors[0].epochColor, anchors[0].styleColor);
      setSlotInstant(elEpochSlot, elEpochCurrent, elEpochNext, anchors[0].epochTitle);
      setSlotInstant(elStyleSlot, elStyleCurrent, elStyleNext, anchors[0].styleTitle);
      computeActiveByScroll();
    }

    window.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", onScroll);
    onScroll();
  };

  init().catch((e) => {
    setSlotInstant(elEpochSlot, elEpochCurrent, elEpochNext, "Ошибка");
    setSlotInstant(elStyleSlot, elStyleCurrent, elStyleNext, String(e));
  });
});
</script>

<style>
.tl3__mainTitle {
  max-width: 980px;
  margin: 0 auto;
  padding: 60px 16px 30px calc(16px + var(--epochStripeW) + var(--styleStripeW) + var(--textPad));
  font-size: 42px;
  line-height: 1.1;
  font-weight: 900;
  color: #fff;
  letter-spacing: -0.02em;
  text-transform: uppercase;
  position: relative;
  z-index: 10;
}
@media screen and (max-width: 640px) {
  .tl3__mainTitle { font-size: 28px; padding: 40px 16px 20px calc(20px + var(--epochStripeW)); }
}
.tl3{
  font-family: Arial, sans-serif;
  color:#eee;
  background-color: #000;

  --epochStripeW: 24px;
  --styleStripeW: 12px;
  --stripeGap: 0px;
  --textPad: 10px;
}

/* ===== Sticky header ===== */
.tl3__sticky{
  position: sticky;
  top: 0;
  z-index: 50;

  width: 100vw;
  margin-left: calc(50% - 50vw);
  margin-right: calc(50% - 50vw);

  --epochColor: #2F6FED;
  --styleColor: #666;

  --epochBg: color-mix(in srgb, var(--epochColor) 18%, black);
  --styleBg: color-mix(in srgb, var(--styleColor) 14%, black);

  box-shadow: 0 1px 0 rgba(0,0,0,0.10);
}

/* Row background + transition (чтобы смена цвета была мягче) */
.tl3__stickyRow--epoch{ background-color: var(--epochBg); transition: background-color 220ms ease; }
.tl3__stickyRow--style{
  background-color: var(--styleBg);
  transition: background-color 220ms ease;
  box-shadow: 0 -1px 0 rgba(0,0,0,0.06) inset;
}

.tl3__stickyRow{ position: relative; }

/* В строке ЭПОХА — ТОЛЬКО полоса эпохи */
.tl3__stickyRow--epoch::before{
  content:"";
  position:absolute;
  left:0; top:0; bottom:0;
  width: var(--epochStripeW);
  background: var(--epochBg);
  transition: background 220ms ease;
}

/* В строке СТИЛЬ — полоса эпохи + полоса стиля */
.tl3__stickyRow--style::before{
  content:"";
  position:absolute;
  left:0; top:0; bottom:0;
  width: var(--epochStripeW);
  background: var(--epochBg);
  transition: background 220ms ease;
}
.tl3__stickyRow--style::after{
  content:"";
  position:absolute;
  left: calc(var(--epochStripeW) + var(--stripeGap));
  top:0; bottom:0;
  width: var(--styleStripeW);
  background: var(--styleBg);
  transition: background 220ms ease;
}

.tl3__stickyInner{
  max-width: 980px;
  margin: 0 auto;
  padding: 10px 16px 10px calc(
    16px + var(--epochStripeW) + var(--stripeGap) + var(--styleStripeW) + var(--textPad)
  );
  position: relative;
  z-index: 1;
}

.tl3__stickyLabel{
  font-size: 11px;
  letter-spacing: .12em;
  color: rgba(0,0,0,.55);
  font-weight: 900;
}

/* ===== Animated slot ===== */
.tl3__slot{
  margin-top: 4px;
  height: 22px;
  overflow: hidden;
  position: relative;
}

.tl3__slotLine{
  position: absolute;
  left: 0;
  right: 0;
  font-size: 18px;
  font-weight: 900;
  line-height: 22px;
  color:#111;
}

/* reset: отключаем transition чтобы не “прыгал” первый переход */
.tl3__slot--reset .tl3__slotLine{
  transition: none !important;
}

.tl3__slotLine--current{
  transform: translateY(0);
  opacity: 1;
  transition: transform 260ms ease, opacity 260ms ease;
}

.tl3__slotLine--next{
  transform: translateY(110%); /* старт снизу */
  opacity: 0;
  transition: transform 260ms ease, opacity 260ms ease;
}

.tl3__slot--anim .tl3__slotLine--current{
  transform: translateY(-110%); /* уезжает вверх */
  opacity: 0;
}

.tl3__slot--anim .tl3__slotLine--next{
  transform: translateY(0); /* въезжает снизу */
  opacity: 1;
}

/* ===== Epoch group full-bleed + полоса эпохи ===== */
.tl3__epochGroup{
  position: relative;
  width: 100vw;
  margin-left: calc(50% - 50vw);
  margin-right: calc(50% - 50vw);
  --epochBg: color-mix(in srgb, var(--epochColor) 18%, black);
}

.tl3__epochGroup::before{
  content:"";
  position:absolute;
  left:0; top:0; bottom:0;
  width: var(--epochStripeW);
  background: var(--epochBg);
}

.tl3__inner{
  max-width: 980px;
  margin: 0 auto;
  padding: 0 16px 0 calc(
    16px + var(--epochStripeW) + var(--stripeGap) + var(--styleStripeW) + var(--textPad)
  );
}

/* ===== Epoch header row (if shown) ===== */
.tl3__epochHeadRow{
  position: relative;
  background:
    linear-gradient(
      to right,
      transparent 0,
      transparent var(--epochStripeW),
      var(--epochBg) var(--epochStripeW),
      var(--epochBg) 100%
    );
  border-bottom: 1px solid rgba(0,0,0,0.06);
  padding: 14px 0 12px;
}

.tl3__epochHeadLabel{ font-size: 11px; letter-spacing: .12em; color: rgba(0,0,0,.55); font-weight: 900; }
.tl3__epochHeadValue{ margin-top: 4px; font-size: 20px; font-weight: 900; line-height: 1.15; color:#111; }

/* ===== Style row + stripe ===== */
.tl3__styleRow{
  position: relative;
  --styleBg: color-mix(in srgb, var(--styleColor) 14%, black);
}

.tl3__styleRow::before{
  content:"";
  position:absolute;
  left: calc(var(--epochStripeW) + var(--stripeGap));
  top: 0;
  bottom: 0;
  width: var(--styleStripeW);
  background: var(--styleBg);
}

/* ===== Style header row (if shown) ===== */
.tl3__styleHeadRow{
  position: relative;
  background:
    linear-gradient(
      to right,
      transparent 0,
      transparent calc(var(--epochStripeW) + var(--stripeGap) + var(--styleStripeW)),
      var(--styleBg) calc(var(--epochStripeW) + var(--stripeGap) + var(--styleStripeW)),
      var(--styleBg) 100%
    );
  border-bottom: 1px solid rgba(0,0,0,0.06);
  padding: 12px 0 10px;
}

.tl3__styleBody{
  padding-top: 14px;
  padding-bottom: 22px;
  border-bottom: 1px solid rgba(0,0,0,0.06);
}
.tl3__styleBody--nohead{ padding-top: 18px; }

.tl3__styleHeadLabel{ font-size: 11px; letter-spacing: .12em; color: rgba(0,0,0,.55); font-weight: 900; }
.tl3__styleHeadValue{ margin-top: 4px; font-size: 20px; font-weight: 900; line-height: 1.15; color:#111; }
.tl3__pill{ display:inline-block; margin-left: 8px; font-size: 12px; font-weight: 700; color: rgba(0,0,0,.6); }

.tl3__one{ font-size: 14px; font-weight: 900; }
.tl3__desc{ margin-top: 8px; font-size: 14px; line-height: 1.5; color:#222; }

.tl3__block{ margin-top: 14px; }
.tl3__blockTitle{ font-size: 13px; font-weight: 900; margin-bottom: 8px; }
.tl3__muted{ color:#777; font-size: 13px; }

/* ===== Projects ===== */
.tl3__proj{ border: 1px solid rgba(255,255,255,0.1); border-radius: 14px; padding: 12px; background: #111; margin-top: 10px; }
.tl3__projTitle{ color: #fff; }
.tl3__projMeta{ color: #999; }
.tl3__projDesc{ color: #bbb; }
.tl3__epochHeadValue, .tl3__styleHeadValue { color: #fff; }
.tl3__one { color: #fff; }
.tl3__desc { color: #ccc; }
.tl3__blockTitle { color: #fff; }
.tl3__link { color: #fff; }
.tl3__projTitle{ font-size: 14px; font-weight: 900; }
.tl3__projMeta{ margin-top: 4px; font-size: 12px; color:#666; }
.tl3__projDesc{ margin-top: 8px; font-size: 13px; color:#333; line-height: 1.45; }

.tl3__thumbs{ margin-top: 10px; display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.tl3__thumb{ display:block; border-radius: 12px; overflow:hidden; border: 1px solid #eee; background:#f6f6f6; }
.tl3__thumb img{ width: 100%; height: 120px; object-fit: cover; display:block; }

.tl3__link{ color:#111; font-weight: 900; text-decoration: underline; text-decoration-color: rgba(0,0,0,.25); }

/* ===== Vertical dates ===== */
.tl3__tick{
  position: absolute;
  top: 50%;
  transform: translateY(-50%) rotate(180deg);
  writing-mode: vertical-rl;
  text-orientation: mixed;

  font-size: 15px;
  font-weight: 900
  
  letter-spacing: .02em;

  color: rgba(0,0,0,.55);
  text-shadow: 0 1px 0 rgba(255,255,255,.6);
  pointer-events: none;
  user-select: none;
  z-index: 2;
  line-height: 1.1;
}

.tl3__tick--epoch{
  left: calc((var(--epochStripeW) / 2) - 10px);
}

.tl3__tick--style{
  left: calc(var(--epochStripeW) + (var(--styleStripeW) / 2) - 10px);
}

.tl3__tick:empty{ display:none; }

/* fallback if color-mix unsupported */
@supports not (color: color-mix(in srgb, red 10%, black)) {
  .tl3__sticky{ --epochBg:#f3f6ff; --styleBg:#f6f6f6; }
  .tl3__epochGroup{ --epochBg:#f3f6ff; }
  .tl3__styleRow{ --styleBg:#f6f6f6; }
}
</style>